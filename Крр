using System;
using System.Collections.Generic;
using System.Threading;

public enum LogLevel
{
    Debug,
    Info,
    Warning,
    Error
}

public class LogMessage
{
    public string Content { get; set; }
    public LogLevel Level { get; set; }
    public DateTime Timestamp { get; set; }
    public string Source { get; set; }

    public LogMessage(string source, string content, LogLevel level)
    {
        Source = source;
        Content = content;
        Level = level;
        Timestamp = DateTime.Now;
    }
}

public interface ILogTarget
{
    void Log(LogMessage message);
    bool ShouldLog(LogMessage message);
}

public class Logger
{
    private Dictionary<string, ILogTarget> targets = new Dictionary<string, ILogTarget>();

    public event Action<LogMessage> MessageLogged;

    public void AddTarget(string name, ILogTarget target)
    {
        if (string.IsNullOrEmpty(name))
            throw new ArgumentException("Name cannot be null or empty", nameof(name));
        
        targets[name] = target;
    }

    public void RemoveTarget(string name)
    {
        targets.Remove(name);
    }

    public void Debug(string source, string content)
    {
        LogInternal(source, content, LogLevel.Debug);
    }

    public void Info(string source, string content)
    {
        LogInternal(source, content, LogLevel.Info);
    }

    public void Warning(string source, string content)
    {
        LogInternal(source, content, LogLevel.Warning);
    }

    public void Error(string source, string content)
    {
        LogInternal(source, content, LogLevel.Error);
    }

    public void Clear()
    {
        foreach (var target in targets.Values)
        {
            if (target is MemoryTarget memoryTarget)
            {
                memoryTarget.Clear();
            }
        }
    }

    private void LogInternal(string source, string content, LogLevel level)
    {
        var message = new LogMessage(source, content, level);
        
        foreach (var target in targets.Values)
        {
            if (target.ShouldLog(message))
            {
                target.Log(message);
            }
        }

        MessageLogged?.Invoke(message);
    }
}

public class ConsoleTarget : ILogTarget
{
    public LogLevel MinLevel { get; }

    public ConsoleTarget(LogLevel minLevel)
    {
        MinLevel = minLevel;
    }

    public bool ShouldLog(LogMessage message)
    {
        return message.Level >= MinLevel;
    }

    public void Log(LogMessage message)
    {
        var originalColor = Console.ForegroundColor;
        var originalBgColor = Console.BackgroundColor;

        SetColors(message.Level);
        
        string levelStr = message.Level switch
        {
            LogLevel.Debug => "DEBUG",
            LogLevel.Info => "INFO",
            LogLevel.Warning => "WARNING",
            LogLevel.Error => "ERROR",
            _ => "UNKNOWN"
        };

        Console.WriteLine($"[{levelStr}] {message.Timestamp:yyyy-MM-dd HH:mm:ss} | {message.Content}");
        
        Console.ForegroundColor = originalColor;
        Console.BackgroundColor = originalBgColor;
    }

    private void SetColors(LogLevel level)
    {
        switch (level)
        {
            case LogLevel.Debug:
                Console.ForegroundColor = ConsoleColor.Blue;
                Console.BackgroundColor = ConsoleColor.Gray;
                break;
            case LogLevel.Info:
                Console.ForegroundColor = ConsoleColor.White;
                Console.BackgroundColor = ConsoleColor.Black;
                break;
            case LogLevel.Warning:
                Console.ForegroundColor = ConsoleColor.Black;
                Console.BackgroundColor = ConsoleColor.Yellow;
                break;
            case LogLevel.Error:
                Console.ForegroundColor = ConsoleColor.White;
                Console.BackgroundColor = ConsoleColor.Red;
                break;
        }
    }
}

public class MemoryTarget : ILogTarget
{
    public LogLevel MinLevel { get; }
    public int MaxMessages { get; }
    public List<LogMessage> Messages { get; private set; }

    public MemoryTarget(LogLevel minLevel, int maxMessages = 100)
    {
        MinLevel = minLevel;
        MaxMessages = maxMessages;
        Messages = new List<LogMessage>();
    }

    public bool ShouldLog(LogMessage message)
    {
        return message.Level >= MinLevel;
    }

    public void Log(LogMessage message)
    {
        Messages.Add(message);
        
        // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
        if (Messages.Count > MaxMessages)
        {
            Messages.RemoveAt(0);
        }
    }

    public List<LogMessage> GetMessages()
    {
        return new List<LogMessage>(Messages);
    }

    public void Clear()
    {
        Messages.Clear();
    }
}

public class Program
{
    static void Main()
    {
        Console.OutputEncoding = System.Text.Encoding.Unicode;

        var logger = new Logger();

        // –°–æ–∑–¥–∞–µ–º —Ü–µ–ª–µ–≤—ã–µ –º–µ—Å—Ç–∞
        var consoleTarget = new ConsoleTarget(LogLevel.Warning);
        var memoryTarget = new MemoryTarget(LogLevel.Debug, 100); // –•—Ä–∞–Ω–∏–º 100 —Å–æ–æ–±—â–µ–Ω–∏–π

        // –î–æ–±–∞–≤–ª—è–µ–º —Ü–µ–ª–∏
        logger.AddTarget("–ö–æ–Ω—Å–æ–ª—å", consoleTarget);
        logger.AddTarget("–ü–∞–º—è—Ç—å", memoryTarget);

        // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ —Å–æ–±—ã—Ç–∏—è
        logger.MessageLogged += (message) =>
            Console.WriteLine($"üìù –ó–∞–ø–∏—Å–∞–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ: {message.Source} {message.Content}");

        Console.WriteLine("=== –¢–µ—Å—Ç 1: –†–∞–∑–Ω—ã–µ —É—Ä–æ–≤–Ω–∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è ===");
        logger.Debug("–¢–µ—Å—Ç1", "–û—Ç–ª–∞–¥–æ—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ");
        logger.Info("–¢–µ—Å—Ç1", "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ");
        logger.Warning("–¢–µ—Å—Ç1", "–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ");
        logger.Error("–¢–µ—Å—Ç1", "–û—à–∏–±–∫–∞ –≤ —Å–∏—Å—Ç–µ–º–µ");

        // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è —Ä–∞–∑–ª–∏—á–∏—è –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –º–µ—Ç–æ–∫
        Thread.Sleep(100);

        Console.WriteLine("\n=== –¢–µ—Å—Ç 2: –°–æ–æ–±—â–µ–Ω–∏—è —Å —Ä–∞–∑–Ω—ã–º–∏ –∏—Å—Ç–æ—á–Ω–∏–∫–∞–º–∏ ===");
        logger.Info("–¢–µ—Å—Ç2", "–ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è");
        logger.Info("–¢–µ—Å—Ç2", "–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö");
        logger.Warning("–¢–µ—Å—Ç2", "–ú–µ–¥–ª–µ–Ω–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ");

        Thread.Sleep(100);

        Console.WriteLine("\n=== –¢–µ—Å—Ç 3: –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–∞–º—è—Ç–∏ ===");
        for (int i = 0; i < 105; i++)
        {
            logger.Info("–¢–µ—Å—Ç3", $"–¢–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ {i + 1}");
        }

        Console.WriteLine($"\n–°–æ–æ–±—â–µ–Ω–∏–π –≤ –ø–∞–º—è—Ç–∏: {memoryTarget.GetMessages().Count}");
        Console.WriteLine($"–ü–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ø–∞–º—è—Ç–∏: {memoryTarget.Messages[memoryTarget.Messages.Count - 1].Content}");

        Console.WriteLine("\n=== –¢–µ—Å—Ç 4: –û—á–∏—Å—Ç–∫–∞ –ª–æ–≥–æ–≤ ===");
        logger.Clear();
        Console.WriteLine("–õ–æ–≥–∏ –æ—á–∏—â–µ–Ω—ã");
        Console.WriteLine($"–°–æ–æ–±—â–µ–Ω–∏–π –≤ –ø–∞–º—è—Ç–∏: {memoryTarget.GetMessages().Count}");
    }
}
